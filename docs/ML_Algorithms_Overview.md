# Алгоритмы ML, модели и адаптация под edge (обзор проекта)

## Данные и признаки (21 вход)
- Используем табличный датасет на основе КТГ (`f_health.csv`) с 21 признаком (примеры):
  - baseline value, accelerations, fetal_movement, uterine_contractions
  - abnormal_short_term_variability, mean_value_of_short_term_variability
  - percentage_of_time_with_abnormal_long_term_variability, mean_value_of_long_term_variability
  - семейство histogram_* (width, min, max, variance и т.д.)
- Целевая переменная (мультикласс): fetal_health ∈ {1=Normal, 2=Suspect, 3=Pathological}.

## Модель текущего состояния (best_fetal_model.pkl)
- Тренировочный скрипт: `fetal_ml_model.py`.
- Подход:
  - Собираем несколько пайплайнов (RandomForest, GradientBoosting, LogisticRegression, SVM).
  - В каждом пайплайне — импутация (медиана) и при необходимости масштабирование (для линейных/ SVM).
  - 5-кратная стратифицированная кросс-валидация на трейне, выбираем лучший по среднему AUC (ovr).
  - Дообучаем лучший на полном трейне, валидируем на отложенном тесте.
  - Сохраняем весь sklearn Pipeline в `best_fetal_model.pkl` и упорядоченный список признаков в `best_fetal_model_features.pkl`.
- Почему эта модель?
  - Табличные данные среднего размера → ансамбли деревьев (GB/RF) часто дают высокий результат без тяжёлого фичеринга.
  - Пайплайн с импутацией/масштабированием повышает устойчивость к пропускам и сдвигам распределений.
  - Лёгкая по вычислениям — подходит для CPU-only edge.
- Как работает в рантайме:
  - Предиктор принимает вектор признаков строго в порядке из `best_fetal_model_features.pkl`.
  - Пайплайн применяет импутацию и выдаёт вероятности по 3 классам.
  - В потоках (001–002) маппим «живые» метрики в 21 признак; отсутствующие заполняем медианами из `f_health.csv`, чтобы быть совместимыми с пайплайном.

## Прогнозные модели (forecast_model_10/30/60.pkl)
- Тренировочный скрипт: `fetal_forecasting.py`.
- Задача: вероятности нескольких диагнозов на горизонтах 10/30/60 минут на основе скользящего окна агрегатов.
- Признаки окна (см. `compute_window_features`):
  - fhr_mean, fhr_std, uc_mean, uc_std, accel_rate, decel_rate, variability_mean (nan-safe).
- Метки по горизонту (multi-label):
  - fetal_bradycardia, fetal_tachycardia, low_variability, uterine_tachysystole, any_pathology.
- Выбор модели: по одному пайплайну GradientBoosting на метку (imputer+scaler+GBC) для каждого горизонта.
  - Храним в одном файле на горизонт со структурой:
    - { pipelines: {label -> Pipeline}, labels: [...], feature_names: [...], window_sec: int, horizon_min: int }
- Почему так?
  - Разложение на независимые бинарные задачи держит модели компактными и устойчивыми.
  - GB быстро работает на CPU и хорошо справляется с табличными агрегатами окон.
- В рантайме в потоках:
  - Ведём скользящий буфер последних точек (FHR/UC/accel/decel/variability).
  - Когда длина буфера достигает обученного окна (обычно ~300с), считаем агрегаты и прогоняем пайплайны по всем горизонтам.
  - В JSON включаем прогнозы по горизонту как словарь «метка → вероятность».

## Интеграция в реальном времени (потоки)
- Персональные SSE-потоки: `/stream/patient/{id}`.
  - 001–002 с ML включены, 003–006 временно отключены для снижения нагрузки.
  - Каждое сообщение содержит кадр симулятора плюс объект `ml`:
    - ml.prediction (Normal/Suspect/Pathological)
    - ml.confidence и ml.probabilities
    - ml.forecasts (по горизонтам 10/30/60 мин), когда буфер достаточно наполнен.
- Контроль нагрузки на edge:
  - Симуляция ~10 Гц для плавной отрисовки.
  - Инференс ML дросселирован до 2 Гц на поток (между апдейтами повторяем последний результат).
  - Лекарства кэшируются по patient_id, чтобы не дёргать Mongo при каждом переподключении SSE.

## Адаптация под edge (ARM64/x86_64, 4 vCPU, 8 GB RAM)
- Основной рантайм: sklearn через PKL (проще, надёжно, воспроизводимо).
  - `/ml/diagnostics` показывает активный источник (sklearn_pkl или onnxruntime).
  - PKL используется, если ONNX отсутствует.
- Опциональный ускоренный путь: ONNX Runtime + INT8.
  - `onnx_export_quant_bench.py` — экспорт sklearn→ONNX, динамическая int8-квантизация и бенчмарк латентности.
  - Если есть `best_fetal_model.int8.onnx`, `RealtimeFetalPredictor` использует ORT с настройками потоков под 4 ядра (intra_op=2, inter_op=1).
  - Даёт переносимые ускорения на ARM64/x86_64 при той же схеме признаков.
- Специфика Rockchip/Intel (опционально):
  - ONNX→RKNN (Rockchip NPU) или ONNX→OpenVINO (Intel CPU/iGPU); ORT остаётся запасным.
- Управление ресурсами в рантайме:
  - ML-троттлинг до 2 Гц, batch=1, повтор последнего результата.
  - Uvicorn с 1 воркером на малых узлах; наращивать только при запасе CPU.
  - Простые in-memory кэши для устранения повторных запросов к БД.

## Почему именно такие алгоритмы?
- Табличная классификация/прогнозирование с прозрачными признаками — хороший баланс интерпретируемости и пригодности к edge:
  - Ансамбли деревьев + лёгкий препроцессинг — быстро, экономно по памяти, понятно для аудита.
  - Оконные агрегаты для прогноза — устойчиво и не переобучается как сложные временные модели на небольших выборках.
- Дизайн пайплайнов позволяет в любой момент перейти на ONNX без изменения потоковой логики.

## Обучение и валидация
- Классификация:
  - Стратифицированный train/test; 5-fold CV на трейне для выбора по AUC (ovr).
  - Финальные метрики в логах, сохраняем модель и порядок признаков.
- Прогнозирование:
  - Строим оконные агрегаты и метки на каждом горизонте.
  - Независимые GB-пайплайны по меткам, с кросс-валидацией при наличии вариативности классов.
  - Сохраняем «пакеты» пайплайнов на горизонт; длина окна хранится внутри для рантайма.

## Ограничения и как их смягчаем
- «Холодный старт» потока: пока буфер не накоплен, прогнозы пустые → показываем пусто до появления данных.
- Несоответствие live-признаков и обучающих:
  - Заполняем недостающие признаки медианами из обучающего набора, чтобы избежать NaN.
  - По мере появления новых live-полей — расширяем маппинг в 21 признаковое поле.
- Тестовые правила симулятора (ярлыки брадикардии/тахикардии) могут не совпадать с решением ML при нормальной полной картине 21 признака — ожидаемо на тестовых окнах.

## Быстрые ссылки на эндпоинты
- `/stream/patient/001`, `/stream/patient/002` — SSE с ML; содержат блок `ml`.
- `/stream/patient/{id}` — универсальный SSE с ML (для реальных ID) — по включению.
- `/ml/diagnostics` — активный источник модели (PKL/ONNX), число признаков, наличие прогнозов и файлов.


